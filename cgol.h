#ifndef _CGOL_H
#define _CGOL_H

////////////////////// Common headers //////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>

// For C99 fixed-width integer types and their corresponding printf directives.
#include <stdint.h>
#include <inttypes.h>

#include <time.h> // for seeding srand()

////////////////////// Defines //////////////////////

#define STR_MAXLEN 2048

// Some minimums for the viewport grid size, to be able to better show the
// evolution. We set the minimum to CGOL_WORD_BITS, and will deal with the
// viewport grid in chunks of CGOL_WORD_BITS.
#define GRID_MIN_ROWS 8
#define GRID_MIN_COLS 8

// The size, in bits, of our word, used to create
// the viewport grid bitfield.
// We will be using a bitfield array for the viewport grid.
// Since our minimum grid size is 8x8, we set this to 64 bits.
// NOTE: a 64-bit number can fit comfortably in a single register on a 64-bit
// machine, and CPU cache lines are usually 64 bytes, so we should have
// decent word and cache alignment.
// Later, when we generalize the rows and columns, we might want to use a
// suitable word size.
#define CGOL_WORD_BITS (((uint64_t)(sizeof(uint64_t)*CHAR_BIT)))

#define DEFAULT_GENERATIONS 4

// This isn't used yet, but we have it for future use
#define MAX_GENERATIONS UINT64_MAX

// To stringify enums and things.
// See https://gcc.gnu.org/onlinedocs/gcc-4.6.2/cpp/Stringification.html
#define STR(s) #s
#define XSTR(s) STR(s)

// For debugging things
// Stolen from: https://stackoverflow.com/a/67667132
// NOTE: The definition of DEBUG will come from the compilation command line.
#ifdef DEBUG
    #define DEBUG_PRINTF(fmt, ...) printf("DEBUG: "fmt,  __VA_ARGS__)
#else
    #define DEBUG_PRINTF(...) do {} while (0)
#endif

// Bit-twiddling. The "bitpos" arg is zero-based.
#define SET_BIT_ULL(num, bitpos) ((num) |= (1ULL << (bitpos)))
#define CLEAR_BIT_ULL(num, bitpos) ((num) &= (~(1ULL << (bitpos))))
#define TOGGLE_BIT_ULL(num, bitpos) ((num) ^= (1ULL << (bitpos)))
#define TEST_BIT_ULL(num, bitpos) (((num) & (1ULL << (bitpos))) != 0)

// Defines for starting patterns for an 8x8 grid.
// Generated by laying out the bit pattern for the corresponding starting
// pattern into an 8x8 array of 0s and 1s, and then converting that binary
// array representation into a single number.
// The "LSB" i.e row 0 column 0, is the bottom-right corner of the grid/array.
// See convert_grid_shape_into_number_TEST() in life_test.c
// ***WARNING:*** These numbers are a grid representation ONLY for grids where
// the number of cells (rows*cols) is 64.
// TODO: Generalize this to any row/column layout
#define BLINKER_8x8 34494480384
#define TOAD_8x8 121198608384
#define BEACON_8x8 1695550411898880

////////////////////// Constants //////////////////////
typedef enum starting_pattern { // TODO: Support the more complicated starting patterns
    RANDOM,
    BEACON,
    BLINKER,
    TOAD
} Starting_Pattern;

typedef enum case_conv_op {
    TO_UPPER,
    TO_LOWER
} Case_Conv_Op;


////////////////////// Prototypes //////////////////////

// Convert an entire string to upper or lower case.
static inline bool upper_lower_str(Case_Conv_Op op,
        const char* in,
        char* out, size_t strlen_of_out) {
    size_t instrlen;
    
    // which case conversion function do we want?
    int (*casefunc)(int) = toupper;
    if(op == TO_LOWER) {
        casefunc = tolower;
    }

    // sanity
    if( (!in) || (!out) ) {
        return false;
    }
    instrlen = strnlen(in, STR_MAXLEN);
    if((instrlen == 0) || (instrlen > strlen_of_out)) {
        return false;
    }

    // DO EET!
    while(*in) {
        *out++ = casefunc(*in++);
    }   
    *out = '\0';
    return true;
}

// ------------- Prototypes for functions in life.c ---------------
// Main entry point into the Game of Life.
void start_life(uint8_t rows, uint8_t cols,
        Starting_Pattern pattern_val, uint64_t generations,
        const char *user_arg);

// Convert a row and column address into a toroidal bit position.
// This translates a grid reference into a bit position in the Game of Life
// "bit array" which contains the viewport grid.
uint32_t row_col_to_bitpos_toroidal(int16_t row, int16_t col,
        uint8_t num_rows, uint8_t num_cols);

// Print the 64-bit number which represents the toroidal game grid as an actual
// grid composed of n rows of "cols" columns each.
// We only need the number of columns to determine when to move to the next row,
// since we are in row-major format.
void print_grid(uint64_t num, uint8_t cols);

// ------------ Entry point for test harness in life_tests.c ----------
// These do nothing in release mode
void perform_life_TESTS(uint8_t rows, uint8_t cols, uint64_t lg1, uint64_t lg2);

#endif
